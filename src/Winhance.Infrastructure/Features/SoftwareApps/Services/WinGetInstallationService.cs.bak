using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Management.Automation;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using Winhance.Core.Features.Common.Enums;
using Winhance.Core.Features.Common.Interfaces;
using Winhance.Core.Features.Common.Models;
using Winhance.Core.Features.SoftwareApps.Enums;
using Winhance.Core.Features.SoftwareApps.Exceptions;
using Winhance.Core.Features.SoftwareApps.Helpers;
using Winhance.Core.Features.SoftwareApps.Interfaces;
using Winhance.Infrastructure.Features.Common.Utilities;

namespace Winhance.Infrastructure.Features.SoftwareApps.Services;

/// <summary>
/// Service that handles WinGet-related installation operations.
/// </summary>
public class WinGetInstallationService : IWinGetInstallationService, IDisposable
{
    private readonly ILogService _logService;
    private readonly ISystemServices _systemServices;
    private readonly string _tempDir = Path.Combine(Path.GetTempPath(), "WinhanceInstaller");
    private IProgress<TaskProgressDetail>? _currentProgress;

    /// <summary>
    /// Initializes a new instance of the <see cref="WinGetInstallationService"/> class.
    /// </summary>
    /// <param name="logService">The log service.</param>
    /// <param name="systemServices">The system services.</param>
    public WinGetInstallationService(ILogService logService, ISystemServices systemServices)
    {
        _logService = logService;
        _systemServices = systemServices;
        Directory.CreateDirectory(_tempDir);
    }

    /// <inheritdoc/>
    public async Task<bool> InstallWithWingetAsync(
        string packageName,
        IProgress<TaskProgressDetail>? progress = null,
        CancellationToken cancellationToken = default,
        string? displayName = null
    )
    {
        _currentProgress = progress;

        try
        {
            // Check for internet connectivity before starting the installation
            bool isConnected = await _systemServices.IsInternetConnectedAsync(true, cancellationToken);
            if (!isConnected)
            {
                string errorMessage = "No internet connection available. Please check your network connection and try again.";
                _logService.LogError(errorMessage);
                _logService.LogError($"Failed to install {displayName ?? packageName} - No internet connection");
                progress?.Report(
                    new TaskProgressDetail
                    {
                        Progress = 0,
                        StatusText = "Installation failed: No internet connection",
                        DetailedMessage = errorMessage,
                        LogLevel = LogLevel.Error,
                    }
                );
                return false;
            }
            if (string.IsNullOrWhiteSpace(packageName))
            {
                throw new ArgumentException(
                    "Package name cannot be null or empty",
                    nameof(packageName)
                );
            }

            // Report initial progress
            progress?.Report(
                new TaskProgressDetail
                {
                    Progress = 0,
                    StatusText = $"Starting installation of {displayName ?? packageName}...",
                    DetailedMessage =
                        $"Preparing to install {displayName ?? packageName} using WinGet",
                }
            );

            // Create PowerShell instance - using the factory to ensure compatibility
            var powerShell = PowerShellFactory.CreateWindowsPowerShell(
                _logService,
                _systemServices
            );

            // First check if WinGet is installed
            _currentProgress?.Report(
                new TaskProgressDetail
                {
                    Progress = 5,
                    StatusText = "Checking if WinGet is installed...",
                    DetailedMessage = "Verifying if WinGet is already installed on the system",
                }
            );

            powerShell.AddScript("winget --version");
            var result = await powerShell.InvokeAsync();

            if (!result.Any())
            {
                _currentProgress?.Report(
                    new TaskProgressDetail
                    {
                        Progress = 10,
                        StatusText = "WinGet not found. Installing WinGet first...",
                        DetailedMessage = "WinGet is not installed. Installing it now.",
                    }
                );
                await InstallWinGetAsync(progress);

                // After installing WinGet, dispose the current PowerShell instance and create a new one
                // to ensure we can use the newly installed WinGet
                powerShell.Dispose();

                _logService.LogInformation(
                    "Creating new PowerShell instance after WinGet installation"
                );

                // Create a new PowerShell instance
                powerShell = PowerShellFactory.CreateWindowsPowerShell(
                    _logService,
                    _systemServices
                );

                // Verify WinGet installation was successful
                powerShell.AddScript("winget --version");
                result = await powerShell.InvokeAsync();

                if (!result.Any())
                {
                    throw new Exception(
                        "Failed to install WinGet. Unable to continue with package installation."
                    );
                }

                _logService.LogInformation(
                    "WinGet verification successful, continuing with package installation"
                );
            }

            // Call the internal method to install the package
            await InstallWithWingetInternalAsync(
                packageName,
                displayName,
                progress,
                cancellationToken
            );

            // Check internet connection before reporting completion
            bool internetLostDuringInstallation = false;
            isConnected = await _systemServices.IsInternetConnectedAsync(true, cancellationToken);
            if (!isConnected)
            {
                internetLostDuringInstallation = true;
                string errorMessage = "Internet connection lost during installation. Installation has been stopped.";
                _logService.LogError(errorMessage);
                progress?.Report(
                    new TaskProgressDetail
                    {
                        Progress = 90,
                        StatusText = "Installation failed: Internet connection lost",
                        DetailedMessage = errorMessage,
                        LogLevel = LogLevel.Error,
                    }
                );
                // When internet connection is lost, we consider the installation failed
                // This is more reliable than trying to verify an incomplete installation
                return false;
            }

            // Verify the app was actually installed
            bool isInstalled = await VerifyAppInstallationAsync(packageName);
            
            if (isInstalled)
            {
                // Report successful completion
                if (internetLostDuringInstallation)
                {
                    _logService.LogSuccess($"Successfully installed {displayName ?? packageName} despite internet connection issues");
                    progress?.Report(
                        new TaskProgressDetail
                        {
                            Progress = 100,
                            StatusText = $"{displayName ?? packageName} installed successfully!",
                            DetailedMessage =
                                $"Successfully installed {displayName ?? packageName}. Note: Internet connection was lost during installation, but all necessary files were already downloaded.",
                            LogLevel = LogLevel.Success,
                        }
                    );
                }
                else
                {
                    _logService.LogSuccess($"Successfully installed {displayName ?? packageName} using WinGet");
                    progress?.Report(
                        new TaskProgressDetail
                        {
                            Progress = 100,
                            StatusText = $"{displayName ?? packageName} installed successfully!",
                            DetailedMessage =
                                $"Successfully installed {displayName ?? packageName} using WinGet",
                            LogLevel = LogLevel.Success,
                        }
                    );
                }
                
                return true;
            }
            else
            {
                // Report failure if verification failed
                string errorMessage;
                if (internetLostDuringInstallation)
                {
                    errorMessage = "Installation verification failed. The app could not be installed correctly due to internet connection issues.";
                    _logService.LogError(errorMessage);
                    _logService.LogError($"Failed to install {displayName ?? packageName} - Internet connection lost during installation");
                    progress?.Report(
                        new TaskProgressDetail
                        {
                            Progress = 0,
                            StatusText = "Installation failed: Internet connection lost",
                            DetailedMessage = errorMessage,
                            LogLevel = LogLevel.Error,
                        }
                    );
                }
                else
                {
                    errorMessage = "Installation verification failed. The app may not have been installed correctly.";
                    _logService.LogError(errorMessage);
                    _logService.LogError($"Failed to install {displayName ?? packageName} - Installation verification failed");
                    progress?.Report(
                        new TaskProgressDetail
                        {
                            Progress = 0,
                            StatusText = "Installation failed: Verification failed",
                            DetailedMessage = errorMessage,
                            LogLevel = LogLevel.Error,
                        }
                    );
                }
                
                return false;
            }
        }
        catch (OperationCanceledException)
        {
            var errorType = InstallationErrorType.CancelledByUserError;
            var errorMessage = InstallationErrorHelper.GetUserFriendlyErrorMessage(errorType);

            progress?.Report(
                new TaskProgressDetail
                {
                    Progress = 0,
                    StatusText = $"Installation of {displayName ?? packageName} was cancelled",
                    DetailedMessage = errorMessage,
                    LogLevel = LogLevel.Warning,
                }
            );

            throw new InstallationException(
                packageName,
                errorMessage,
                false,
                errorType,
                new OperationCanceledException()
            );
        }
        catch (InstallationException)
        {
            // Re-throw InstallationException without wrapping
            throw;
        }
        catch (Exception ex)
        {
            // Determine the error type based on the exception message
            var errorType = InstallationErrorHelper.DetermineErrorType(ex.Message);
            var errorMessage = InstallationErrorHelper.GetUserFriendlyErrorMessage(errorType);

            progress?.Report(
                new TaskProgressDetail
                {
                    Progress = 0,
                    StatusText = $"Error installing {displayName ?? packageName}: {errorMessage}",
                    DetailedMessage = $"Exception during installation: {ex.Message}",
                    LogLevel = LogLevel.Error,
                    AdditionalInfo = new Dictionary<string, string>
                    {
                        { "ErrorType", errorType.ToString() },
                        { "PackageName", packageName },
                        { "OriginalError", ex.Message },
                    },
                }
            );

            return false;
        }
        finally
        {
            // Clear the progress reporter
            _currentProgress = null;
        }
    }

    /// <inheritdoc/>
    public async Task<bool> IsWinGetInstalledAsync()
    {
        _logService.LogInformation("Checking if WinGet is installed...");

        // Create PowerShell instance
        using var powerShell = PowerShellFactory.CreateWindowsPowerShell(
            _logService,
            _systemServices
        );

        try
        {
            // Script to check if WinGet is installed and accessible
            // Use multiple detection methods to improve reliability
            var checkScript =
                @"
                try {
                    # Method 1: Try to run a simple winget command
                    try {
                        $output = winget --version 2>&1
                        if ($LASTEXITCODE -eq 0) {
                            Write-Output ""WinGet is installed. Version: $output""
                            return $true
                        }
                    } catch {
                        # Continue to next method if this fails
                    }
                    
                    # Method 2: Check if the winget executable exists in the PATH
                    try {
                        $wingetPath = Get-Command winget -ErrorAction SilentlyContinue
                        if ($wingetPath) {
                            Write-Output ""WinGet is installed at: $($wingetPath.Source)""
                            return $true
                        }
                    } catch {
                        # Continue to next method if this fails
                    }
                    
                    # Method 3: Check for the Microsoft.DesktopAppInstaller package
                    try {
                        $appxPackage = Get-AppxPackage -Name Microsoft.DesktopAppInstaller -ErrorAction SilentlyContinue
                        if ($appxPackage) {
                            Write-Output ""WinGet is installed via Microsoft.DesktopAppInstaller package version: $($appxPackage.Version)""
                            return $true
                        }
                    } catch {
                        # Continue to next method if this fails
                    }
                    
                    # Method 4: Check if WinGet module is installed
                    try {
                        $module = Get-Module -Name Microsoft.WinGet.Client -ListAvailable -ErrorAction SilentlyContinue
                        if ($module) {
                            Write-Output ""WinGet PowerShell module is installed: $($module.Version)""
                            return $true
                        }
                    } catch {
                        # Continue if this fails
                    }
                    
                    # If all methods fail, WinGet is not installed
                    Write-Output ""WinGet is not installed or not accessible""
                    return $false
                } catch {
                    Write-Output ""Error checking WinGet: $($_.Exception.Message)""
                    return $false
                }
            ";

            powerShell.AddScript(checkScript);
            var results = await powerShell.InvokeAsync();

            bool isInstalled = false;
            if (results.Count > 0)
            {
                // Convert the result to a boolean value
                try
                {
                    if (results[0] is PSObject psObject)
                    {
                        if (psObject.BaseObject is bool boolValue)
                        {
                            isInstalled = boolValue;
                        }
                        else
                        {
                            // Try to convert the value to boolean
                            isInstalled = Convert.ToBoolean(psObject.BaseObject);
                        }
                    }
                    else
                    {
                        isInstalled = Convert.ToBoolean(results[0]);
                    }
                }
                catch
                {
                    // If conversion fails, assume false
                    isInstalled = false;
                }
            }

            _logService.LogInformation(
                $"WinGet installation check result: {(isInstalled ? "Installed" : "Not installed")}"
            );
            return isInstalled;
        }
        catch (Exception ex)
        {
            _logService.LogError($"Error checking WinGet installation: {ex.Message}", ex);
            return false;
        }
    }

    /// <inheritdoc/>
    public async Task InstallWinGetAsync(IProgress<TaskProgressDetail>? progress = null)
    {
        progress?.Report(
            new TaskProgressDetail
            {
                Progress = 10,
                StatusText = "Installing WinGet...",
                DetailedMessage =
                    "Starting WinGet installation process using Windows PowerShell 5.1",
            }
        );

        // Create a temporary script file
        string scriptPath = Path.Combine(_tempDir, $"WinGetInstall_{Guid.NewGuid()}.ps1");

        // Use the Microsoft recommended PowerShell script to install WinGet
        string installScript =
            @"
            $progressPreference = 'silentlyContinue'
            
            # Report progress at each major step
            Write-Host ""[PROGRESS:15] Starting WinGet installation...""
            
            Write-Host ""Installing WinGet PowerShell module from PSGallery...""
            Write-Host ""[PROGRESS:25] Installing NuGet package provider...""
            Install-PackageProvider -Name NuGet -Force | Out-Null
            
            Write-Host ""[PROGRESS:40] Installing Microsoft.WinGet.Client module...""
            Install-Module -Name Microsoft.WinGet.Client -Force -Repository PSGallery | Out-Null
            
            Write-Host ""[PROGRESS:60] Using Repair-WinGetPackageManager cmdlet to bootstrap WinGet...""
            Repair-WinGetPackageManager -AllUsers
            
            Write-Host ""[PROGRESS:85] Finalizing WinGet installation...""
            Write-Host ""Done.""
        ";

        // Write the installation script to the file
        File.WriteAllText(scriptPath, installScript);

        try
        {
            progress?.Report(
                new TaskProgressDetail
                {
                    Progress = 20,
                    StatusText = "Downloading and installing WinGet components...",
                    DetailedMessage =
                        "Downloading and installing required WinGet components using Windows PowerShell 5.1",
                }
            );

            // Create a process to run Windows PowerShell 5.1 directly
            using var process = new System.Diagnostics.Process();
            process.StartInfo.FileName =
                @"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe";
            process.StartInfo.Arguments = $"-ExecutionPolicy Bypass -File \"{scriptPath}\"";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.CreateNoWindow = true;

            var outputBuilder = new System.Text.StringBuilder();
            var errorBuilder = new System.Text.StringBuilder();

            // Regular expression to extract progress information
            var progressRegex = new Regex(@"\[PROGRESS:(\d+)\]\s*(.*)", RegexOptions.Compiled);

            process.OutputDataReceived += (sender, e) =>
            {
                if (e.Data != null)
                {
                    outputBuilder.AppendLine(e.Data);
                    _logService.LogInformation($"WinGet Install: {e.Data}");

                    // Check if the output contains progress information
                    var match = progressRegex.Match(e.Data);
                    if (match.Success && int.TryParse(match.Groups[1].Value, out int progressValue))
                    {
                        string message = match.Groups[2].Value;
                        progress?.Report(
                            new TaskProgressDetail
                            {
                                Progress = progressValue,
                                StatusText = "Installing WinGet...",
                                DetailedMessage = message,
                            }
                        );
                    }
                }
            };

            process.ErrorDataReceived += (sender, e) =>
            {
                if (e.Data != null)
                {
                    errorBuilder.AppendLine(e.Data);
                    _logService.LogError($"WinGet Install Error: {e.Data}");
                }
            };

            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            // Create a timer to provide more granular progress updates for long-running operations
            using var timer = new System.Timers.Timer(1000); // Update every second
            var startTime = DateTime.Now;
            var lastReportedProgress = 20;

            timer.Elapsed += (s, e) =>
            {
                // Only update progress if we haven't received explicit progress updates recently
                // and the process is still running
                if (!process.HasExited)
                {
                    // Calculate elapsed time since start
                    var elapsed = (DateTime.Now - startTime).TotalSeconds;

                    // Estimate progress based on elapsed time
                    // Assume WinGet installation takes about 60 seconds total
                    int estimatedProgress = Math.Min(85, 20 + (int)(elapsed / 60 * 65));

                    // Only update if progress has increased
                    if (estimatedProgress > lastReportedProgress)
                    {
                        lastReportedProgress = estimatedProgress;

                        // Determine the current phase based on progress
                        string detailMessage;
                        if (estimatedProgress < 30)
                            detailMessage = "Preparing NuGet package provider...";
                        else if (estimatedProgress < 50)
                            detailMessage = "Installing Microsoft.WinGet.Client module...";
                        else if (estimatedProgress < 70)
                            detailMessage = "Bootstrapping WinGet package manager...";
                        else
                            detailMessage = "Finalizing WinGet installation...";

                        progress?.Report(
                            new TaskProgressDetail
                            {
                                Progress = estimatedProgress,
                                StatusText = "Installing WinGet...",
                                DetailedMessage = detailMessage,
                            }
                        );
                    }
                }
            };

            // Start the timer
            timer.Start();

            await Task.Run(() => process.WaitForExit());

            // Stop the timer
            timer.Stop();
            timer.Dispose();

            if (process.ExitCode != 0)
            {
                string errorMessages = errorBuilder.ToString();
                throw new Exception($"Failed to install WinGet. Error: {errorMessages}");
            }

            progress?.Report(
                new TaskProgressDetail
                {
                    Progress = 90,
                    StatusText = "WinGet installation completed.",
                    DetailedMessage =
                        "WinGet has been successfully installed using Windows PowerShell 5.1",
                }
            );
        }
        catch (Exception ex)
        {
            var errorType = InstallationErrorHelper.DetermineErrorType(ex.Message);
            var errorMessage = InstallationErrorHelper.GetUserFriendlyErrorMessage(errorType);

            throw new InstallationException(
                "WinGet",
                $"Error installing WinGet: {errorMessage}",
                true,
                errorType,
                ex
            );
        }
        finally
        {
            // Clean up the temporary script file
            try
            {
                if (File.Exists(scriptPath))
                {
                    File.Delete(scriptPath);
                }
            }
            catch (Exception ex)
            {
                _logService.LogError($"Error cleaning up temporary script file: {ex.Message}", ex);
                // Ignore cleanup errors
            }
        }
    }

    /// <summary>
    /// Internal method to install a package using WinGet.
    /// </summary>
    private async Task InstallWithWingetInternalAsync(
        string packageName,
        string? displayName,
        IProgress<TaskProgressDetail>? progress,
        CancellationToken cancellationToken
    )
    {
        // Verify internet connectivity before starting the installation
        bool isConnected = await _systemServices.IsInternetConnectedAsync(true, cancellationToken);
        if (!isConnected)
        {
            string errorMessage = "No internet connection available. Please check your network connection and try again.";
            _logService.LogError(errorMessage);
            _logService.LogError($"Failed to install {displayName ?? packageName} - No internet connection");
            progress?.Report(
                new TaskProgressDetail
                {
                    Progress = 0,
                    StatusText = "Installation failed: No internet connection",
                    DetailedMessage = errorMessage,
                    LogLevel = LogLevel.Error,
                }
            );
            throw new InstallationException(
                packageName,
                errorMessage,
                false,
                InstallationErrorType.NetworkError,
                new Exception("No internet connection available")
            );
        }

        string friendlyName = displayName ?? packageName;

        _logService.LogInformation($"Installing Windows App: {friendlyName}");
        _logService.LogInformation($"Preparing to install {friendlyName}");

        progress?.Report(
            new TaskProgressDetail
            {
                Progress = 10,
                StatusText = $"Installing {friendlyName}...",
                DetailedMessage = $"Starting WinGet installation for {friendlyName}",
            }
        );

        // Create PowerShell instance
        using var powerShell = PowerShellFactory.CreateWindowsPowerShell(
            _logService,
            _systemServices
        );

        // Create a timer to provide more granular progress updates
        var timer = new System.Timers.Timer(500);
        var startTime = DateTime.Now;
        var lastReportedProgress = 10;
        var currentPhase = "Preparing";
        var phaseStartTimes = new Dictionary<string, DateTime>
        {
            { "Preparing", DateTime.Now },
            { "Downloading", DateTime.MinValue },
            { "Verifying", DateTime.MinValue },
            { "Installing", DateTime.MinValue },
            { "Completing", DateTime.MinValue },
        };
        
        // Track sub-phases within the installation phase
        var installationSubPhase = "Starting";
        var lastInstallationProgressReport = DateTime.MinValue;
        var lastCompletingProgressReport = DateTime.MinValue;
        var installationProgressInterval = TimeSpan.FromSeconds(1); // Report every 1 second during installation
        var completingProgressInterval = TimeSpan.FromSeconds(2); // Report every 2 seconds during completing phase
        var forcedProgressReporting = false; // Flag to enable forced progress reporting during stalled periods
        var maxStallTime = TimeSpan.FromSeconds(3); // Maximum time to allow without progress updates

        // Variables for periodic internet connectivity checks
        var lastConnectivityCheckTime = DateTime.Now;
        var connectivityCheckInterval = TimeSpan.FromSeconds(5); // Check connectivity every 5 seconds

        // Setup the timer to report progress
        timer.Elapsed += async (s, e) =>
        {
            // Only report if PowerShell is still running
            if (powerShell.InvocationStateInfo.State == PSInvocationState.Running)
            {
                // Periodically check internet connectivity during installation
                if ((DateTime.Now - lastConnectivityCheckTime) >= connectivityCheckInterval)
                {
                    lastConnectivityCheckTime = DateTime.Now;
                    bool isConnected = false;
                    
                    try
                    {
                        isConnected = await _systemServices.IsInternetConnectedAsync(false, cancellationToken);
                    }
                    catch (Exception ex)
                    {
                        _logService.LogError($"Error checking internet connectivity: {ex.Message}");
                        // Assume connected to avoid false positives
                        isConnected = true;
                    }
                    
                    if (!isConnected)
                    {
                        _logService.LogError("Internet connection lost during installation");
                        progress?.Report(
                            new TaskProgressDetail
                            {
                                Progress = lastReportedProgress,
                                StatusText = "Error: Internet connection lost",
                                DetailedMessage = "Internet connection has been lost. Installation has been stopped.",
                                LogLevel = LogLevel.Error,
                            }
                        );
                        
                        // Stop the timer
                        timer.Stop();
                        
                        // Stop the PowerShell process safely
                        try {
                            powerShell.Stop();
                        } catch (Exception ex) {
                            _logService.LogError($"Error stopping PowerShell: {ex.Message}");
                        }
                        
                        // Return from the timer callback without throwing an exception
                        // This prevents the exception from potentially crashing the application
                        // Instead, we'll set a flag that the main thread can check
                        forcedProgressReporting = true;
                        return;
                    }
                }

                // Calculate overall progress based on elapsed time
                var totalElapsed = (DateTime.Now - startTime).TotalSeconds;
                var estimatedTotalTime = 60; // Assume 60 seconds for a typical installation
                var overallProgress = Math.Min(85, (int)(totalElapsed / estimatedTotalTime * 100));

                // Ensure progress is always increasing
                if (overallProgress <= lastReportedProgress)
                {
                    overallProgress = lastReportedProgress + 1;
                }

                // Cap at 85% to leave room for verification
                overallProgress = Math.Min(85, overallProgress);

                // Check if we're in a potential stall period (no progress updates for more than maxStallTime)
                var timeSinceLastReport = DateTime.Now - lastInstallationProgressReport;
                var timeSinceLastCompletingReport = DateTime.Now - lastCompletingProgressReport;
                
                if ((currentPhase == "Installing" && timeSinceLastReport > maxStallTime) ||
                    (currentPhase == "Completing" && timeSinceLastCompletingReport > maxStallTime))
                {
                    // Enable forced progress reporting
                    forcedProgressReporting = true;
                }

                // Only report if progress has changed or we're in forced reporting mode
                if (overallProgress > lastReportedProgress || forcedProgressReporting)
                {
                    lastReportedProgress = overallProgress;
                    forcedProgressReporting = false; // Reset the flag after reporting

                    // Determine current phase based on elapsed time
                    if (totalElapsed > 45 && currentPhase != "Completing")
                    {
                        currentPhase = "Completing";
                        phaseStartTimes["Completing"] = DateTime.Now;
                        lastCompletingProgressReport = DateTime.Now;
                    }
                    else if (
                        totalElapsed > 30
                        && currentPhase != "Installing"
                        && currentPhase != "Completing"
                    )
                    {
                        currentPhase = "Installing";
                        phaseStartTimes["Installing"] = DateTime.Now;
                        installationSubPhase = "Starting";
                    }
                    else if (
                        totalElapsed > 15
                        && currentPhase != "Verifying"
                        && currentPhase != "Installing"
                        && currentPhase != "Completing"
                    )
                    {
                        currentPhase = "Verifying";
                        phaseStartTimes["Verifying"] = DateTime.Now;
                    }
                    else if (totalElapsed > 5 && currentPhase == "Preparing")
                    {
                        currentPhase = "Downloading";
                        phaseStartTimes["Downloading"] = DateTime.Now;
                    }

                    // Calculate phase-specific progress
                    var phaseElapsed = (DateTime.Now - phaseStartTimes[currentPhase]).TotalSeconds;
                    var phaseProgress = 0;

                    switch (currentPhase)
                    {
                        case "Downloading":
                            phaseProgress = Math.Min(100, (int)(phaseElapsed / 10 * 100)); // Assume 10 seconds for downloading
                            break;
                        case "Verifying":
                            phaseProgress = Math.Min(100, (int)(phaseElapsed / 15 * 100)); // Assume 15 seconds for verifying
                            break;
                        case "Installing":
                            phaseProgress = Math.Min(100, (int)(phaseElapsed / 15 * 100)); // Assume 15 seconds for installing
                            
                            // Update installation sub-phase based on progress
                            if (phaseProgress >= 85 && installationSubPhase != "Finalizing")
                            {
                                installationSubPhase = "Finalizing";
                            }
                            else if (phaseProgress >= 60 && installationSubPhase != "Registering")
                            {
                                installationSubPhase = "Registering";
                            }
                            else if (phaseProgress >= 30 && installationSubPhase != "Copying")
                            {
                                installationSubPhase = "Copying";
                            }
                            
                            // For the installation phase, provide more frequent updates during the 50-85% range
                            // This is the critical period where progress reporting was stalling
                            if (phaseProgress >= 50)
                            {
                                // Check if we need to report more frequently during this critical phase
                                if ((DateTime.Now - lastInstallationProgressReport) >= installationProgressInterval)
                                {
                                    lastInstallationProgressReport = DateTime.Now;
                                    
                                    // Calculate a more granular sub-phase progress that continues to increase
                                    // even when the actual progress might be stalled
                                    var timeInSubPhase = (DateTime.Now - lastInstallationProgressReport).TotalSeconds;
                                    var adjustedSubPhaseProgress = phaseProgress;
                                    
                                    if (phaseProgress >= 50 && phaseProgress < 60)
                                    {
                                        installationSubPhase = "Copying";
                                        adjustedSubPhaseProgress = 50 + (int)(timeInSubPhase * 2);
                                        adjustedSubPhaseProgress = Math.Min(59, adjustedSubPhaseProgress);
                                    }
                                    else if (phaseProgress >= 60 && phaseProgress < 85)
                                    {
                                        installationSubPhase = "Registering";
                                        adjustedSubPhaseProgress = 60 + (int)(timeInSubPhase * 2);
                                        adjustedSubPhaseProgress = Math.Min(84, adjustedSubPhaseProgress);
                                    }
                                    else
                                    {
                                        installationSubPhase = "Finalizing";
                                        adjustedSubPhaseProgress = 85 + (int)(timeInSubPhase * 1);
                                        adjustedSubPhaseProgress = Math.Min(99, adjustedSubPhaseProgress);
                                    }
                                    
                                    // Report more detailed progress during installation
                                    progress?.Report(
                                        new TaskProgressDetail
                                        {
                                            Progress = overallProgress,
                                            StatusText = $"Installing {friendlyName}... {installationSubPhase} ({adjustedSubPhaseProgress}%)",
                                            DetailedMessage = GetDetailedMessageForPhase(
                                                friendlyName,
                                                "Installing",
                                                adjustedSubPhaseProgress
                                            ),
                                            AdditionalInfo = new Dictionary<string, string>
                                            {
                                                { "SubPhase", installationSubPhase },
                                                { "ElapsedTime", $"{totalElapsed:F1} seconds" },
                                                { "ForcedUpdate", "true" }
                                            }
                                        }
                                    );
                                    
                                    // Return early to avoid duplicate progress reports
                                    return;
                                }
                            }
                            break;
                        case "Completing":
                            // Use a time-based progress calculation that ensures continuous updates
                            // even during the final phase where actual progress might be stalled
                            var completingElapsed = (DateTime.Now - phaseStartTimes["Completing"]).TotalSeconds;
                            
                            // Assume the completing phase takes about 30 seconds (adjust based on actual observations)
                            var estimatedCompletingTime = 30.0;
                            phaseProgress = Math.Min(99, (int)(completingElapsed / estimatedCompletingTime * 100));
                            
                            // Ensure progress is always increasing
                            phaseProgress = Math.Max(phaseProgress, 5 * (int)(completingElapsed / 2)); // At least 5% every 2 seconds
                            
                            // For the completing phase, provide more frequent updates to prevent the appearance of stalling
                            if ((DateTime.Now - lastCompletingProgressReport) >= completingProgressInterval)
                            {
                                lastCompletingProgressReport = DateTime.Now;
                                
                                // Calculate a scaled overall progress that goes from 85% to 95%
                                var scaledOverallProgress = 85 + (int)(phaseProgress * 0.1); // Scale to 85-95% range
                                
                                // Report progress during the completing phase
                                progress?.Report(
                                    new TaskProgressDetail
                                    {
                                        Progress = scaledOverallProgress,
                                        StatusText = $"Finalizing installation of {friendlyName}... ({phaseProgress}%)",
                                        DetailedMessage = $"Finalizing installation of {friendlyName}: Registering components and creating shortcuts ({phaseProgress}% complete)",
                                        AdditionalInfo = new Dictionary<string, string>
                                        {
                                            { "Phase", "Completing" },
                                            { "ElapsedTime", $"{completingElapsed:F1} seconds" },
                                            { "ForcedUpdate", "true" }
                                        }
                                    }
                                );
                                
                                // Return early to avoid duplicate progress reports
                                return;
                            }
                            break;
                        default:
                            phaseProgress = Math.Min(100, (int)(phaseElapsed / 5 * 100)); // Assume 5 seconds for preparing
                            break;
                    }

                    // Report progress
                    progress?.Report(
                        new TaskProgressDetail
                        {
                            Progress = 10 + (int)(overallProgress * 0.8), // Scale to 10-90% range
                            StatusText =
                                $"Installing {friendlyName}... {currentPhase} ({phaseProgress}%)",
                            DetailedMessage = GetDetailedMessageForPhase(
                                friendlyName,
                                currentPhase,
                                phaseProgress
                            ),
                        }
                    );
                }
            }
        };
        
        try
        {
            // Start the timer
            timer.Start();

            // Create a script that will install the package using WinGet
            var installScript =
                $@"
                try {{
                    # For Microsoft Store apps (package IDs that are alphanumeric with no dots), use msstore source explicitly
                    $useStoreSource = '{packageName}' -match '^[A-Z0-9]+$'
                    $sourceArg = if ($useStoreSource) {{ '--source msstore' }} else {{ '' }}
                    
                    # Start the winget process with more detailed output
                    $processInfo = New-Object System.Diagnostics.ProcessStartInfo
                    $processInfo.FileName = 'winget'
                    $processInfo.Arguments = 'install --id {packageName} -e --accept-package-agreements --accept-source-agreements --disable-interactivity --silent --force ' + $sourceArg
                    $processInfo.RedirectStandardOutput = $true
                    $processInfo.RedirectStandardError = $true
                    $processInfo.UseShellExecute = $false
                    $processInfo.CreateNoWindow = $true
                    
                    Write-Output ""Running command: winget $($processInfo.Arguments)""
                    
                    $process = New-Object System.Diagnostics.Process
                    $process.StartInfo = $processInfo
                    $process.Start() | Out-Null
                    
                    # Monitor the process
                    $startTime = Get-Date
                    $estimatedDuration = New-TimeSpan -Minutes 5  # Increased timeout for store apps
                    $outputBuilder = New-Object System.Text.StringBuilder
                    $lastOutput = """"
                    $lastProgressReport = 0
                    $installPhase = ""Preparing""
                    $installSubPhase = ""Starting""
                    $lastDetailedReport = Get-Date
                    $lastCompletingReport = Get-Date
                    $detailedReportInterval = [TimeSpan]::FromSeconds(1)  # Report more frequently
                    $completingReportInterval = [TimeSpan]::FromSeconds(2)  # Report during completing phase
                    
                    # Start async reading
                    $outputTask = $process.StandardOutput.ReadToEndAsync()
                    $errorTask = $process.StandardError.ReadToEndAsync()
                    
                    # Create a reader to read output as it becomes available
                    $reader = $process.StandardOutput.BaseStream
                    $buffer = New-Object byte[] 4096
                    
                    while (!$process.HasExited) {{
                        # Calculate time-based progress
                        $elapsed = (Get-Date) - $startTime
                        $timeProgress = [Math]::Min(1.0, $elapsed.TotalMilliseconds / $estimatedDuration.TotalMilliseconds)
                        $timeProgressPercent = [int]($timeProgress * 100)
                        
                        # Try to read any available output
                        if ($reader.CanRead -and $reader.DataAvailable) {{
                            $bytesRead = $reader.Read($buffer, 0, $buffer.Length)
                            if ($bytesRead -gt 0) {{
                                $text = [System.Text.Encoding]::UTF8.GetString($buffer, 0, $bytesRead)
                                $outputBuilder.Append($text)
                                $lastOutput = $text
                                
                                # Determine installation phase based on output
                                if ($text -match ""Downloading"") {{ $installPhase = ""Downloading"" }}
                                elseif ($text -match ""Verifying"") {{ $installPhase = ""Verifying"" }}
                                elseif ($text -match ""Installing"") {{ 
                                    $installPhase = ""Installing"" 
                                    
                                    # Try to determine sub-phase based on output
                                    if ($text -match ""Creating shortcuts"") {{ $installSubPhase = ""Registering"" }}
                                    elseif ($text -match ""Registering"") {{ $installSubPhase = ""Registering"" }}
                                    elseif ($text -match ""Copying"") {{ $installSubPhase = ""Copying"" }}
                                    elseif ($text -match ""Extracting"") {{ $installSubPhase = ""Copying"" }}
                                    elseif ($text -match ""Finalizing"") {{ $installSubPhase = ""Finalizing"" }}
                                }}
                                elseif ($text -match ""Completing"") {{ $installPhase = ""Completing"" }}
                            }}
                        }}
                        
                        # Only report progress if it's changed by at least 2% or the phase has changed
                        if (($timeProgressPercent - $lastProgressReport) -ge 2) {{
                            Write-Output ""Progress: $timeProgressPercent% - $installPhase""
                            $lastProgressReport = $timeProgressPercent
                        }}
                        
                        # For the critical installation phase (around 50-99%), provide more detailed progress reports
                        if ($installPhase -eq ""Installing"" -and $timeProgressPercent -ge 50) {{
                            $now = Get-Date
                            if (($now - $lastDetailedReport) -ge $detailedReportInterval) {{
                                # Calculate sub-phase progress
                                $subPhaseProgress = 0
                                
                                # Determine sub-phase based on time progress
                                if ($timeProgressPercent -lt 60) {{
                                    $installSubPhase = ""Copying""
                                    $subPhaseProgress = 50 + [Math]::Min(9, [int](($now - $lastDetailedReport).TotalSeconds * 2))
                                }}
                                elseif ($timeProgressPercent -lt 75) {{
                                    $installSubPhase = ""Registering""
                                    $subPhaseProgress = 60 + [Math]::Min(14, [int](($now - $lastDetailedReport).TotalSeconds * 2))
                                }}
                                elseif ($timeProgressPercent -lt 85) {{
                                    $installSubPhase = ""Registering""
                                    $subPhaseProgress = 75 + [Math]::Min(9, [int](($now - $lastDetailedReport).TotalSeconds * 2))
                                }}
                                else {{
                                    $installSubPhase = ""Finalizing""
                                    $subPhaseProgress = 85 + [Math]::Min(14, [int](($now - $lastDetailedReport).TotalSeconds))
                                }}
                                
                                # Force progress to increase over time even if actual progress is stalled
                                $elapsedSinceLastOutput = ($now - $lastDetailedReport).TotalSeconds
                                if ($elapsedSinceLastOutput -gt 3) {{
                                    # If more than 3 seconds have passed, ensure progress increases
                                    $subPhaseProgress += [int]($elapsedSinceLastOutput / 3)
                                }}
                                
                                # Cap at 99%
                                $subPhaseProgress = [Math]::Min(99, $subPhaseProgress)
                                
                                Write-Output ""Detailed Progress: $timeProgressPercent% - $installPhase - $installSubPhase - $subPhaseProgress%""
                                $lastDetailedReport = $now
                            }}
                        }}
                        
                        # For the completing phase, provide continuous progress updates
                        if ($installPhase -eq ""Completing"") {{
                            $now = Get-Date
                            if (($now - $lastCompletingReport) -ge $completingReportInterval) {{
                                # Calculate completing phase progress based on elapsed time
                                $completingElapsed = ($now - $lastCompletingReport).TotalSeconds
                                
                                # Estimate a total completing time of 30 seconds
                                $estimatedCompletingTime = 30.0
                                $completingProgress = [Math]::Min(99, [int]($completingElapsed / $estimatedCompletingTime * 100))
                                
                                # Ensure progress increases even during stalls
                                $completingProgress = [Math]::Max($completingProgress, 5 * [int]($completingElapsed / 2))
                                
                                # Report detailed progress for the completing phase
                                Write-Output ""Completing Progress: $timeProgressPercent% - Completing - $completingProgress%""
                                $lastCompletingReport = $now
                            }}
                        }}
                        
                        # Wait a bit before checking again
                        Start-Sleep -Milliseconds 200
                    }}
                    
                    # Get the output
                    $output = $outputTask.Result
                    $errorOutput = $errorTask.Result
                    
                    Write-Output ""Command output: $output""
                    if ($errorOutput) {{ Write-Output ""Error output: $errorOutput"" }}
                    Write-Output ""Exit code: $($process.ExitCode)""
                    
                    # Check for success indicators in the output
                    $isSuccessful = $output -match 'Successfully installed' -or 
                                $output -match 'already installed' -or
                                $output -match 'Installation complete' -or
                                $process.ExitCode -eq 0 -or
                                # Special case: For Windows Store apps, exit code -1 is often a success
                                ($useStoreSource -and $process.ExitCode -eq -1)
                    
                    # If that fails, try a second installation attempt with msstore source explicitly
                    if (!$isSuccessful -and !$useStoreSource) {{
                        Write-Output ""First attempt failed, trying with msstore source explicitly...""
                        
                        $processInfo = New-Object System.Diagnostics.ProcessStartInfo
                        $processInfo.FileName = 'winget'
                        $processInfo.Arguments = 'install --id {packageName} -e --source msstore --accept-package-agreements --accept-source-agreements --disable-interactivity --silent --force'
                        $processInfo.RedirectStandardOutput = $true
                        $processInfo.RedirectStandardError = $true
                        $processInfo.UseShellExecute = $false
                        $processInfo.CreateNoWindow = $true
                        
                        Write-Output ""Running command: winget $($processInfo.Arguments)""
                        
                        $process = New-Object System.Diagnostics.Process
                        $process.StartInfo = $processInfo
                        $process.Start() | Out-Null
                        
                        # Start async reading
                        $outputTask = $process.StandardOutput.ReadToEndAsync()
                        $errorTask = $process.StandardError.ReadToEndAsync()
                        
                        $process.WaitForExit()
                        
                        # Get the output
                        $output = $outputTask.Result
                        $errorOutput = $errorTask.Result
                        
                        Write-Output ""Second attempt output: $output""
                        if ($errorOutput) {{ Write-Output ""Second attempt error output: $errorOutput"" }}
                        Write-Output ""Second attempt exit code: $($process.ExitCode)""
                        
                        # Check for success indicators in the output
                        $isSuccessful = $output -match 'Successfully installed' -or 
                                       $output -match 'already installed' -or
                                       $output -match 'Installation complete' -or
                                       $process.ExitCode -eq 0
                    }}
                    
                    # Some packages might return non-zero exit codes even on successful installation
                    # So we check both the exit code and the output
                    if ($isSuccessful) {{
                        Write-Output ""Installation completed successfully""
                        return @{{
                            Success = $true
                            Message = ""Installation completed successfully""
                            ExitCode = $process.ExitCode
                            Output = $output
                        }}
                    }} else {{
                        return @{{
                            Success = $false
                            Message = ""Installation failed with exit code: $($process.ExitCode)""
                            ExitCode = $process.ExitCode
                            Output = $output
                            Error = $errorOutput
                        }}
                    }}
                }} catch {{
                    Write-Output ""Exception occurred: $($_.Exception.Message)""
                    return @{{
                        Success = $false
                        Message = ""Exception: $($_.Exception.Message)""
                        ExitCode = -1
                        Error = $_.Exception.ToString()
                    }}
                }}
            ";

            powerShell.AddScript(installScript);

            // Create a data event handler to process output in real-time
            var progressRegex = new Regex(@"Progress: (\d+)% - (\w+)", RegexOptions.Compiled);
            var simpleProgressRegex = new Regex(@"Progress: (\d+)%", RegexOptions.Compiled);
            var detailedProgressRegex = new Regex(@"Detailed Progress: (\d+)% - (\w+) - (\w+) - (\d+)%", RegexOptions.Compiled);
            var completingRegex = new Regex(@"Completing Progress: (\d+)% - Completing - (\d+)%", RegexOptions.Compiled);

            // Set up the information stream handler
            EventHandler<DataAddedEventArgs> informationHandler = (sender, e) =>
            {
                var info = powerShell.Streams.Information[e.Index];
                var data = info.MessageData.ToString() ?? "";

                _logService.LogInformation($"WinGet output: {data}");

                // First check for detailed progress reports
                var detailedMatch = detailedProgressRegex.Match(data);
                if (detailedMatch.Success && 
                    int.TryParse(detailedMatch.Groups[1].Value, out int overallProgress) &&
                    int.TryParse(detailedMatch.Groups[4].Value, out int subPhaseProgress))
                {
                    string phase = detailedMatch.Groups[2].Value;
                    string subPhase = detailedMatch.Groups[3].Value;

                    // Scale progress from 10-90% range
                    var scaledProgress = 10 + (overallProgress * 0.8);
                    progress?.Report(
                        new TaskProgressDetail
                        {
                            Progress = (int)scaledProgress,
                            StatusText = $"Installing {friendlyName}... {subPhase} ({subPhaseProgress}%)",
                            DetailedMessage = GetDetailedMessageForPhase(
                                friendlyName,
                                phase,
                                subPhaseProgress
                            ),
                            AdditionalInfo = new Dictionary<string, string>
                            {
                                { "SubPhase", subPhase },
                                { "OverallProgress", overallProgress.ToString() }
                            }
                        }
                    );
                    
                    // Update the last installation progress report time
                    lastInstallationProgressReport = DateTime.Now;
                    return;
                }

                var match = progressRegex.Match(data);
                if (match.Success && int.TryParse(match.Groups[1].Value, out int progressValue))
                {
                    string phase = match.Groups[2].Value;

                    // Scale progress from 10-90% range
                    var scaledProgress = 10 + (progressValue * 0.8);
                    progress?.Report(
                        new TaskProgressDetail
                        {
                            Progress = (int)scaledProgress,
                            StatusText = $"Installing {friendlyName}... {progressValue}% - {phase}",
                            DetailedMessage = GetDetailedMessageForPhase(
                                friendlyName,
                                phase,
                                progressValue
                            ),
                        }
                    );
                }
                else
                {
                    // Try the simple progress regex as fallback
                    match = simpleProgressRegex.Match(data);
                    if (
                        match.Success
                        && int.TryParse(match.Groups[1].Value, out int progressPercent)
                    )
                    {
                        // Scale progress from 10-90% range
                        var scaledProgress = 10 + (progressPercent * 0.8);
                        progress?.Report(
                            new TaskProgressDetail
                            {
                                Progress = (int)scaledProgress,
                                StatusText = $"Installing {friendlyName}... {progressPercent}%",
                                DetailedMessage =
                                    $"Installation of {friendlyName} is {progressPercent}% complete",
                            }
                        );
                    }
                    else if (
                        data.Contains("Installation completed successfully")
                        || data.Contains("already installed")
                    )
                    {
                        progress?.Report(
                            new TaskProgressDetail
                            {
                                Progress = 100,
                                StatusText = $"{friendlyName} installed successfully!",
                                DetailedMessage =
                                    $"Successfully installed {friendlyName} using WinGet",
                            }
                        );
                    }
                    else
                    {
                        // Check for completing phase progress reports
                        var completingMatch = completingRegex.Match(data);
                        if (completingMatch.Success && 
                            int.TryParse(completingMatch.Groups[1].Value, out int overallCompletingProgress) &&
                            int.TryParse(completingMatch.Groups[2].Value, out int completingProgress))
                        {
                            // Scale progress from 85-95% range for completing phase
                            var scaledProgress = 85 + (completingProgress * 0.1);
                            
                            progress?.Report(
                                new TaskProgressDetail
                                {
                                    Progress = (int)scaledProgress,
                                    StatusText = $"Finalizing installation of {friendlyName}... ({completingProgress}%)",
                                    DetailedMessage = $"Finalizing installation of {friendlyName}: Registering components and creating shortcuts ({completingProgress}% complete)",
                                    AdditionalInfo = new Dictionary<string, string>
                                    {
                                        { "Phase", "Completing" },
                                        { "OverallProgress", overallCompletingProgress.ToString() }
                                    }
                                }
                            );
                            
                            // Update the last completing progress report time
                            lastCompletingProgressReport = DateTime.Now;
                            return;
                        }
                    }
                }
            };

            powerShell.Streams.Information.DataAdded += informationHandler;

            await powerShell.InvokeAsync();

            powerShell.Streams.Information.DataAdded -= informationHandler;
        }
        finally
        {
            timer.Stop();
            timer.Dispose();
        }
    }

    /// <summary>
    /// Gets a detailed message for the current installation phase.
    /// </summary>
    /// <param name="packageName">The name of the package being installed.</param>
    /// <param name="phase">The current installation phase.</param>
    /// <param name="progressValue">The current progress value.</param>
    /// <returns>A detailed message describing the current installation phase.</returns>
    public string GetDetailedMessageForPhase(string packageName, string phase, int progressValue)
    {
        switch (phase.ToLowerInvariant())
        {
            case "downloading":
                return $"Downloading {packageName} from the package source ({progressValue}% complete)";
            case "verifying":
                return $"Verifying package integrity for {packageName} ({progressValue}% complete)";
            case "installing":
                if (progressValue < 30)
                    return $"Starting installation of {packageName} files ({progressValue}% complete)";
                else if (progressValue < 60)
                    return $"Copying {packageName} files to your system ({progressValue}% complete)";
                else if (progressValue < 85)
                    return $"Registering {packageName} components ({progressValue}% complete)";
                else
                    return $"Finalizing installation of {packageName} ({progressValue}% complete)";
            case "completing":
                return $"Completing installation of {packageName} ({progressValue}% complete)";
            default:
                return $"Preparing to install {packageName} ({progressValue}% complete)";
        }
    }

    /// <summary>
    /// Verifies if an app is installed using multiple verification methods.
    /// </summary>
    /// <param name="packageName">The package name or ID to verify.</param>
    /// <returns>True if the app is installed; otherwise, false.</returns>
    public async Task<bool> VerifyAppInstallationAsync(string packageName)
    {
        try
        {
            _logService.LogInformation($"Verifying installation of {packageName}...");
            
            // Create PowerShell instance
            using var powerShell = PowerShellFactory.CreateWindowsPowerShell(
                _logService,
                _systemServices
            );

            // Try multiple verification methods and return true if any of them succeed
            var verificationMethods = new List<Func<Task<bool>>>
            {
                // Method 1: Check using PowerShell Get-Package with wildcards
                async () => 
                {
                    try
                    {
                        _logService.LogInformation($"Verification method 1: Using Get-Package with wildcards for {packageName}");
                        
                        // Convert package name to wildcard format by splitting on dots and surrounding with wildcards
                        var packageParts = packageName.Split('.');
                        
                        // First try with the full package name pattern
                        powerShell.Commands.Clear();
                        powerShell.AddCommand("Get-Package");
                        
                        // Create a wildcard pattern like *Mozilla*Firefox*
                        var wildcardPattern = string.Join("*", packageParts);
                        wildcardPattern = $"*{wildcardPattern}*";
                        
                        powerShell.AddParameter("Name", wildcardPattern);
                        powerShell.AddParameter("ErrorAction", "SilentlyContinue");
                        
                        var results = await powerShell.InvokeAsync();
                        if (results.Count > 0)
                        {
                            _logService.LogSuccess($"Get-Package verification successful for {packageName} using pattern {wildcardPattern}");
                            return true;
                        }
                        
                        // If full pattern didn't work, try with individual parts
                        foreach (var part in packageParts)
                        {
                            // Only try with parts that are at least 3 characters
                            if (part.Length >= 3)
                            {
                                powerShell.Commands.Clear();
                                powerShell.AddCommand("Get-Package");
                                powerShell.AddParameter("Name", $"*{part}*");
                                powerShell.AddParameter("ErrorAction", "SilentlyContinue");
                                
                                results = await powerShell.InvokeAsync();
                                if (results.Count > 0)
                                {
                                    _logService.LogSuccess($"Get-Package verification successful for {packageName} using part {part}");
                                    return true;
                                }
                            }
                        }
                        
                        _logService.LogWarning($"Get-Package verification failed for {packageName}");
                        return false;
                    }
                    catch (Exception ex)
                    {
                        _logService.LogWarning($"Get-Package verification failed: {ex.Message}");
                        return false;
                    }
                },
                
                // Method 2: Check using WinGet list command (kept as fallback)
                async () => 
                {
                    try
                    {
                        _logService.LogInformation($"Verification method 2: Using WinGet list for {packageName}");
                        powerShell.Commands.Clear();
                        powerShell.AddScript(
                            $@"
                            try {{  
                                $result = winget list --id '{packageName}' --exact
                                $isInstalled = $result -match '{packageName}'
                                Write-Output $isInstalled
                            }} catch {{
                                Write-Output $false
                            }}
                        "
                        );

                        var results = await powerShell.InvokeAsync();
                        if (results.Count > 0)
                        {
                            var resultValue = results[0]?.ToString()?.ToLowerInvariant();
                            if (resultValue == "true")
                            {
                                _logService.LogSuccess($"WinGet verification successful for {packageName}");
                                return true;
                            }
                        }
                        return false;
                    }
                    catch (Exception ex)
                    {
                        _logService.LogWarning($"WinGet verification failed: {ex.Message}");
                        return false;
                    }
                },
                
                // Method 2: Check for Microsoft Store apps
                async () =>
                {
                    // Only try this method for Microsoft Store apps (package IDs that are alphanumeric with no dots)
                    if (!packageName.All(char.IsLetterOrDigit) || packageName.Contains('.'))
                        return false;
                        
                    try
                    {
                        _logService.LogInformation($"Verification method 2: Using Get-AppxPackage for {packageName}");
                        powerShell.Commands.Clear();
                        powerShell.AddScript(
                            $"Get-AppxPackage | Where-Object {{ $_.PackageFullName -like '*{packageName}*' }}"
                        );
                        var result = await powerShell.InvokeAsync();

                        if (result.Count > 0)
                        {
                            _logService.LogSuccess($"AppxPackage verification successful for {packageName}");
                            return true;
                        }
                        return false;
                    }
                    catch (Exception ex)
                    {
                        _logService.LogWarning($"AppxPackage verification failed: {ex.Message}");
                        return false;
                    }
                },
                
                // Method 3: Check registry for installed applications
                async () =>
                {
                    try
                    {
                        _logService.LogInformation($"Verification method 3: Checking registry for {packageName}");
                        powerShell.Commands.Clear();
                        powerShell.AddScript(
                            $@"
                            try {{  
                                # Check registry for installed applications
                                $registryPaths = @(
                                    'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*',
                                    'HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*',
                                    'HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*'
                                )
                                
                                foreach ($path in $registryPaths) {{
                                    $installed = Get-ItemProperty $path -ErrorAction SilentlyContinue | 
                                                Where-Object {{ $_.DisplayName -like '*{packageName}*' -or $_.DisplayName -eq '{packageName}' }}
                                    if ($installed) {{
                                        Write-Output 'true'
                                        return
                                    }}
                                }}
                                
                                Write-Output 'false'
                            }} catch {{
                                Write-Output 'false'
                            }}
                        "
                        );

                        var results = await powerShell.InvokeAsync();
                        if (results.Count > 0)
                        {
                            var resultValue = results[0]?.ToString()?.ToLowerInvariant();
                            if (resultValue == "true")
                            {
                                _logService.LogSuccess($"Registry verification successful for {packageName}");
                                return true;
                            }
                        }
                        return false;
                    }
                    catch (Exception ex)
                    {
                        _logService.LogWarning($"Registry verification failed: {ex.Message}");
                        return false;
                    }
                },
                
                // Method 4: Check common installation directories - more strict to avoid false positives
                async () =>
                {
                    try
                    {
                        _logService.LogInformation($"Verification method 4: Checking file system for {packageName}");
                        powerShell.Commands.Clear();
                        powerShell.AddScript(
                            $@"
                            try {{  
                                # Use where.exe to check if the app is in PATH (for CLI tools)
                                $whereResult = where.exe '{packageName}' 2>&1
                                if ($whereResult -notmatch 'not found') {{
                                    # Verify that the found executable actually exists
                                    foreach ($path in $whereResult) {{
                                        if (Test-Path -Path $path -PathType Leaf) {{
                                            Write-Output 'true'
                                            return
                                        }}
                                    }}
                                }}
                                
                                # Check common installation directories
                                $commonPaths = @(
                                    [System.Environment]::GetFolderPath('ProgramFiles'),
                                    [System.Environment]::GetFolderPath('ProgramFilesX86'),
                                    [System.Environment]::GetFolderPath('LocalApplicationData')
                                )
                                
                                # Create a more strict verification - require multiple conditions to be met
                                foreach ($basePath in $commonPaths) {{
                                    # Check for exact directory match AND executable or configuration files
                                    if (Test-Path -Path ""$basePath\{packageName}"" -PathType Container) {{
                                        # Look for executable or configuration files to confirm it's a real installation
                                        $exeExists = Test-Path -Path ""$basePath\{packageName}\{packageName}.exe"" -PathType Leaf
                                        $dllExists = Test-Path -Path ""$basePath\{packageName}\{packageName}.dll"" -PathType Leaf
                                        $configExists = Test-Path -Path ""$basePath\{packageName}\*.config"" -PathType Leaf
                                        $manifestExists = Test-Path -Path ""$basePath\{packageName}\*.manifest"" -PathType Leaf
                                        $iniExists = Test-Path -Path ""$basePath\{packageName}\*.ini"" -PathType Leaf
                                        
                                        # Only return true if we find actual application files, not just a directory
                                        if ($exeExists -or $dllExists -or $configExists -or $manifestExists -or $iniExists) {{
                                            Write-Output 'true'
                                            return
                                        }}
                                    }}
                                    
                                    # For Microsoft Store apps, check for AppxManifest.xml
                                    $storeAppPath = Join-Path -Path ([System.Environment]::GetFolderPath('LocalApplicationData')) -ChildPath ""Packages""
                                    $storeAppDirs = Get-ChildItem -Path $storeAppPath -Directory -ErrorAction SilentlyContinue | 
                                                    Where-Object {{ $_.Name -like ""*{packageName}*"" }}
                                    
                                    foreach ($dir in $storeAppDirs) {{
                                        if (Test-Path -Path ""$($dir.FullName)\AppxManifest.xml"" -PathType Leaf) {{
                                            Write-Output 'true'
                                            return
                                        }}
                                    }}
                                }}
                                
                                Write-Output 'false'
                            }} catch {{
                                Write-Output 'false'
                            }}
                        "
                        );

                        var results = await powerShell.InvokeAsync();
                        if (results.Count > 0)
                        {
                            var resultValue = results[0]?.ToString()?.ToLowerInvariant();
                            if (resultValue == "true")
                            {
                                _logService.LogSuccess($"File system verification successful for {packageName}");
                                return true;
                            }
                        }
                        return false;
                    }
                    catch (Exception ex)
                    {
                        _logService.LogWarning($"File system verification failed: {ex.Message}");
                        return false;
                    }
                }
            };

            // Try each verification method until one succeeds
            foreach (var method in verificationMethods)
            {
                if (await method())
                {
                    return true;
                }
            }

            _logService.LogWarning($"All verification methods failed for {packageName}");
            return false;
        }
        catch (Exception ex)
        {
            // If any error occurs during verification, log it and assume the app is not installed
            _logService.LogError($"Error verifying installation of {packageName}: {ex.Message}");
            return false;
        }
    }

    /// <summary>
    /// Disposes the resources used by the service.
    /// </summary>
    public void Dispose()
    {
        GC.SuppressFinalize(this);
    }
}
